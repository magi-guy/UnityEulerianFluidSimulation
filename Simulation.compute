#pragma kernel CSMain
#pragma kernel BufferToTexture
#pragma kernel CalculateDensity
#pragma kernel Advect

#define TO_BUFFER_INDEX(uv) \
    (uv.y * width + uv.x)
#define TO_TEXTURE_COORDS(i) \
    (uint2( (uint)(i / width), i % width ))

struct cell
{
    float2 position;
    float1 density;
    float2 velocity;
};

RWStructuredBuffer<cell> Fluid;
RWTexture2D<float4> Result;
RWStructuredBuffer<float2> sources; // must be cast to uint2 whenever used
float timeStep;
float width;
float height;
float diff;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DISPATCHTHREADID)
{
    uint index = id.y * width + id.x;
    if(id.x == 0 || id.x == (uint)width-1 || id.y == 0 || id.y == (uint)height-1) {return;}
    
    float1 widthMod = width/32.0;
    Fluid[index] = float4(ceil(sin(id.x/widthMod)), 0.0, -10.0, 1.0);
}

[numthreads(8,8,1)]
void BufferToTexture (uint3 id : SV_DISPATCHTHREADID)
{
    uint index = TO_BUFFER_INDEX(id);

    Result[id] = Fluid[index];

}

[numthreads(8,8,1)]
void CalculateDensity (uint3 id : SV_DISPATCHTHREADID)
{
    uint index = id.y * width + id.x;
    if(id.x == 0 || id.x == (uint)width-1 || id.y == 0 || id.y == (uint)height-1) {return;}

    //Increase Sources
    for(uint i=0; i<sources.Length; i++) {
        if(all((uint2)sources[i] == id.xy)) {
            Fluid[id.xy] += float4(timeStep*1.0, 0.0, 0.0, 0.0);
            break;
        }
    }

    // Set density to the average of the neighbor's densities
    float1 avgDensity = Fluid[uint2(id.x-1, id.y)].x + Fluid[uint2(id.x, id.y-1)].x + Fluid[uint2(id.x+1, id.y)].x + Fluid[uint2(id.x, id.y+1)].x;
    if(
    all(id.xy == uint2(1,1)) || 
    all(id.xy == uint2((uint)width-2,1)) || 
    all(id.xy == uint2(1,(uint)height-2)) || 
    all(id.xy == uint2((uint)width-2,(uint)height-2))
    ) {
        avgDensity /= 2.0;
    } else if(id.x == 1 || id.y == 1 || id.x == (uint)width-2 || id.y == (uint)width-2) {
        avgDensity /= 3.0;
    } else {
        avgDensity /= 4.0;
    }
    Fluid[id.xy] = float4(lerp(Fluid[id.xy].x, avgDensity, diff), Fluid[id.xy].yzw);
}

[numthreads(8,8,1)]
void Advect (uint3 id : SV_DISPATCHTHREADID)
{
    if(id.x == 0 || id.x == (uint)width-1 || id.y == 0 || id.y == (uint)height-1) {return;}

    // Backtrack to find what density was carried here by the velocity field
    float2 backPos = (float2)id.xy - Fluid[id.xy].yz * timeStep;
    float1 backDensity = lerp(
        lerp(Fluid[(int2)backPos].x, Fluid[uint2(ceil(backPos.x),(uint)backPos.y)].x, backPos.x % 1.0),
        lerp(Fluid[uint2((int)backPos.x, ceil(backPos.y))].x, Fluid[ceil(backPos)].x, backPos.x % 1.0),
        backPos.y % 1.0
    );

    Fluid[id.xy] = float4(backDensity, Fluid[id.xy].yzw);
}
